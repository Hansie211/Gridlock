var H=Object.defineProperty;var F=(x,m,g)=>m in x?H(x,m,{enumerable:!0,configurable:!0,writable:!0,value:g}):x[m]=g;var p=(x,m,g)=>(F(x,typeof m!="symbol"?m+"":m,g),g);(function(){"use strict";function g(c){return 100-(70+(c-1)/(9-1)*(95-70))}function A(c){const l=5+Math.floor((c-1)/8*5);return Math.min(l,9)}class N{constructor(e){this.seed=e}getNext(e,t){return t===void 0?this.next(0,e):this.next(e,t)}pick(e){return e[this.getNext(0,e.length-1)]}shuffle(e){const t=[...e];for(let l=t.length-1;l>0;l--){const s=this.getNext(0,l);[t[l],t[s]]=[t[s],t[l]]}return t}}class O extends N{constructor(t){super(t);p(this,"index");this.index=t}next(t,l){if(l<=t)return t;this.index=this.index*1664525+1013904223>>>0;const s=l-t+1;return t+this.index%s}}function v(c){return new O(c)}class z{constructor(e,t,l){p(this,"solution");p(this,"skeleton");this.board=e;const s=S(e),i=z.solve(s,Array.from({length:e.cellcount},()=>0),l);if(i===null)throw new Error("Unsolvable board");this.solution=i,this.skeleton=[...this.solution];const r=l.shuffle(Array.from({length:e.cellcount},(h,d)=>d));for(const h of r){const d=this.skeleton[h];this.skeleton[h]=0;const E=w(h,s,this.skeleton).filter(y=>y!==d);if(E.length===0)continue;let M=!1;for(const y of E)if(this.skeleton[h]=y,z.solve(s,[...this.skeleton],l)!==null){M=!0;break}this.skeleton[h]=M?d:0}const n=g(t),o=l.shuffle(Array.from({length:e.cellcount},(h,d)=>new I(d)).filter(h=>h.getValue(this.skeleton)===0)).map(h=>h.index),f=Math.floor(e.cellcount*(n/100)),u=e.cellcount-o.length,a=Math.max(0,f-u);o.slice(0,a).forEach(h=>{const d=this.solution[h];this.skeleton[h]=d})}static propagate(e,t){let l=!0;for(;l;){l=!1;for(let s=0;s<t.length;s++){if(t[s]!==0)continue;const i=w(s,e,t);if(i.length===0)return!1;i.length===1&&(t[s]=i[0],l=!0)}}return!0}static solve(e,t,l){if(!this.propagate(e,t))return null;let s,i;for(let n=0;n<t.length;n++){if(t[n]!==0)continue;const o=w(n,e,t);if(o.length===0)return null;if((i===void 0||o.length<i.length)&&(s=n,i=o,o.length===1))break}if(s===void 0)return t;const r=i;for(const n of r){t[s]=n;const o=this.solve(e,t,l);if(o!==null)return o;t[s]=0}return null}}function w(c,e,t){const l=e[c].colSegment.map(o=>o.getValue(t)),s=e[c].rowSegment.map(o=>o.getValue(t)),i=new Set([...l,...s].filter(o=>o!==0)),r=Math.min(l.length,s.length),n=[];for(let o=1;o<=r;o++)i.has(o)||n.push(o);return n}class I{constructor(e){this.index=e}getValue(e){return e[this.index]}}function S(c){const e={},t=(l,s)=>l*c.size+s;for(let l=0;l<c.size;l++)for(let s=0;s<c.size;s++){const i=t(l,s),r=[];let n=0;for(const f of c.rows[l]){const u=n+f;if(s>=n&&s<u){for(let a=n;a<u;a++)r.push(new I(t(l,a)));break}n=u}const o=[];n=0;for(const f of c.columns[s]){const u=n+f;if(l>=n&&l<u){for(let a=n;a<u;a++)o.push(new I(t(a,s)));break}n=u}e[i]={rowSegment:r,colSegment:o}}return e}class G{constructor(e,t){p(this,"cellcount");p(this,"rows");p(this,"columns");if(this.size=e,e<5)throw new Error(`Size ${e} is too small`);this.cellcount=this.size*this.size;const l=Array.from({length:this.size},(u,a)=>a),s=Math.max(Math.floor(this.size/2-1)-t.getNext(1),2),i=t.shuffle([...l]).slice(0,s),r=t.shuffle([...l]).slice(0,s),n=Array.from({length:this.size},()=>{});for(const u of i)n[u]=[this.size];const o=Array.from({length:this.size},()=>{});for(const u of r)o[u]=[this.size];if(!k(n,o,t))throw new Error("Unsolvable div board");this.rows=n.map(u=>u.map(a=>a)),this.columns=o.map(u=>u.map(a=>a))}}function R(c,e){const t=c.length,l=Array.from({length:t},()=>Array(t).fill(0)),s=Array.from({length:t},()=>Array(t).fill(0)),i=(r,n)=>{let o=0;for(let f=0;f<r.length;f++){const u=r[f];if(o<=n&&o+u>n)return f;o+=u}throw Error(`Unable to find value ${n} in ${r}`)};for(let r=0;r<t;r++)for(let n=0;n<t;n++){const o=n,f=i(e[o],r);l[r][n]=e[o][f]}for(let r=0;r<t;r++)for(let n=0;n<t;n++){const o=n,f=i(c[o],r);s[r][n]=c[o][f]}return{rowMap:l,colMap:s}}function V(c,e){const t=c.length,{rowMap:l,colMap:s}=R(c,e);for(let i=0;i<t;i++){let r=0;for(const n of c[i]){const o=l[i].slice(r,r+n).sort((f,u)=>u-f);for(let f=0;f<n;f++){const u=n-f;if(o[f]<u)return!1}r+=n}}for(let i=0;i<t;i++){let r=0;for(const n of e[i]){const o=s[i].slice(r,r+n).sort((f,u)=>u-f);for(let f=0;f<n;f++){const u=n-f;if(o[f]<u)return!1}r+=n}}return!0}function k(c,e,t){const l=c.length,s=c.findIndex(o=>o===void 0),i=s===-1?e.findIndex(o=>o===void 0):-1;if(s===-1&&i===-1)return!0;const r={get(){return s!==-1?c[s]:e[i]},set(o){s!==-1?c[s]=o:e[i]=o},reset(){this.set(void 0)}},n=t.shuffle(Array.from({length:l-1},(o,f)=>[f+1,l-(f+1)]));for(const o of n)if(r.set(o),!!V([...c].map(f=>f===void 0?[l]:f),[...e].map(f=>f===void 0?[l]:f))&&k(c,e,t))return!0;return r.reset(),!1}function C(c,e){const t=A(c);for(;;){const l=e.getNext(Number.MAX_SAFE_INTEGER),s=v(l),i=new G(t,s);let r;try{r=new z(i,c,s)}catch(n){if(n.message!=="Unsolvable board")throw n}if(r)return[i,r]}}self.onmessage=async c=>{const{seed:e,difficulty:t}=c.data,l=v(e);try{const[s,i]=C(t,l),r={board:s,solution:i};self.postMessage(r)}catch(s){const i={error:s.message};self.postMessage(i)}}})();
